from snakemake.utils import min_version
min_version("7.0")

# load sample tsv file
# has header line: first must be "sample_accession"
# required columns (again tab separated):
#	sample_accession (SRS1234)
#	run_accession (SRR1234)
#	reference (hs111) # corresponds to the references.tsv file
# 	tech (10xv2, BULK, etc)
#	umi (yes / no)
#   workflow (standard, lammano, nac)
# 	everything else is optional after this
# you absolutely can process the same sample in multiple ways
# e.g. SRS1234 macaque_ref standard_workflow and SRS1234 human_ref nac_workflow
srr_sample_file = config['srr_sample_file']
SRS_dict = metadata_builder(srr_sample_file)
sample_names = list(SRS_dict.keys())

# load ref table
# used to match shorthand (hs111) to full ensembl/refseq/whatever gtf and fasta
# no header
# example hs111 <tab> http://.../Homo_sapiens.GRCh38.111.gtf.gz <tab> http://.../Homo_sapiens.GRCh38.111.fa.gz
ref_file = config['ref_file']
ref_dict = ref_builder(ref_file)



git_dir = config['git_dir']
working_dir = config['working_dir']
conda_dir = config['conda_dir']
fastq_path = config['fastq_path']
quant_path = config['quant_path']
config_abspath=config['config_abspath']

rule all:
	input:
		this_gotta_be_a_common.smk_script_thingy	

rule download_ref:
	output:
		gtf = references/gtf/{reference}.gtf.gz,
		fasta = references/fasta/{reference}.fa.gz
	params:
		gtf_url = lambda wildcards: ref_dict[wildcards.reference]['gtf'],
		fasta_url = lambda wildcards: ref_dict[wildcards.reference]['fasta']
	shell:
		'''
		mkdir -p references
		wget -O {output.gtf} {params.gtf_url}
		wget -O {output.fasta} {params.fasta_url}
		'''


# need to make mouse, human, macaque
rule kb_ref:
	input:
		'references/fasta/{reference}.fasta.gz',
		'references/gtf/{reference}.gtf.gz'
	output:
		idx = 'references/kallisto_idx/{workflow}/{reference}.idx',
		t2g = 'references/t2g/{workflow}/{reference}/t2g.txt',
		cdna = 'references/t2g/{workflow}/{reference}/cdna.fasta'
	conda:
		"../envs/kb.yaml"
	shell:
		"""
		kb ref --workflow {params.workflow} \
			-i {output.idx} \
			-g {output.t2g} \
			-f1 {output.cdna} \
				--include-attribute gene_biotype:protein_coding \
				--include-attribute gene_biotype:lncRNA \
  				--include-attribute gene_biotype:lincRNA \
  				--include-attribute gene_biotype:antisense \
  				--include-attribute gene_biotype:IG_LV_gene \
  				--include-attribute gene_biotype:IG_V_gene \
  				--include-attribute gene_biotype:IG_V_pseudogene \
  				--include-attribute gene_biotype:IG_D_gene \
  				--include-attribute gene_biotype:IG_J_gene \
  				--include-attribute gene_biotype:IG_J_pseudogene \
  				--include-attribute gene_biotype:IG_C_gene \
  				--include-attribute gene_biotype:IG_C_pseudogene \
  				--include-attribute gene_biotype:TR_V_gene \
  				--include-attribute gene_biotype:TR_V_pseudogene \
  				--include-attribute gene_biotype:TR_D_gene \
  				--include-attribute gene_biotype:TR_J_gene \
  				--include-attribute gene_biotype:TR_J_pseudogene \
  				--include-attribute gene_biotype:TR_C_gene \
			{input}
		"""

rule kb_count:
	input:
		fastq = lambda wildcards: lookup_run_from_SRS(wildcards.SRS, fastq_path),
		idx = 'references/kallisto_idx/{tech}/{workflow}/{reference}.idx'
	output:
		h5ad = quant_path + '/quant/{SRS}/{workflow}/{reference}/counts_unfiltered/adata.h5ad',
	threads: 8
	conda:
		"../envs/kb.yaml"
	params:
		tech = lambda wildcards: SRS_dict[wildcards.SRS]['tech'],
		paired_flag = lambda wildcards: '' if SRS_dict[wildcards.SRS]['umi'] else SRS_dict[wildcards.SRS]['paired'],
		out_dir = lambda wildcards:  f'{quant_path}/quant/{wildcards.SRS}/{wildcards.workflow}/{wildcards.reference}'
	shell:
		'''
		kb count {params.paired_flag} \
					--tmp tmp{params.out_dir} \
					--workflow {wildcards.workflow} \
					-t {threads} \
					-x {params.tech} \
					-i {input.idx} \
					-o {params.out_dir} \
					--h5ad --cellranger --filter \
					{input.fastq}
		'''
